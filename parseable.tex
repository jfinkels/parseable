%%%%
%% parseable.tex
%%
%% Copyright 2012 Jeffrey Finkelstein
%%
%% Except where otherwise noted, this work is made available under the terms of
%% the Creative Commons Attribution-ShareAlike 3.0 license,
%% http://creativecommons.org/licenses/by-sa/3.0/.
%%
%% You are free:
%%    * to Share — to copy, distribute and transmit the work
%%    * to Remix — to adapt the work
%% Under the following conditions:
%%    * Attribution — You must attribute the work in the manner specified by
%%    the author or licensor (but not in any way that suggests that they
%%    endorse you or your use of the work).
%%    * Share Alike — If you alter, transform, or build upon this work, you may
%%    distribute the resulting work only under the same, similar or a 
%%    compatible license.
%%    * For any reuse or distribution, you must make clear to others the 
%%    license terms of this work. The best way to do this is with a link to the
%%    web page http://creativecommons.org/licenses/by-sa/3.0/.
%%    * Any of the above conditions can be waived if you get permission from
%%    the copyright holder.
%%    * Nothing in this license impairs or restricts the author's moral rights.
%%%%
\documentclass{article}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{complexity}
\usepackage{float}
\usepackage{syntax}
\usepackage[pdftitle={Parsing first-order propositional logic}, pdfauthor={Jeffrey Finkelstein}]{hyperref}

\floatstyle{ruled}
\restylefloat{figure}

\newtheorem{theorem}{Theorem}

\newtheorem{conjecture}{Conjecture}
\newenvironment{sketch}{\begin{proof}[Proof sketch]}{\end{proof}}
\newenvironment{rationale}{\begin{proof}[Rationale]}{\end{proof}}

\newtheorem{todo}{TODO}
\newtheorem{proposition}{Proposition}
\theoremstyle{remark} \newtheorem{technicality}{Technical note}
\theoremstyle{definition} \newtheorem{definition}{Definition}

\long\def\symbolfootnote#1{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnotetext{#1}\endgroup} 
\newcommand{\makelicense}{
  Copyright 2012 Jeffrey Finkelstein.
  This work is licensed under the Creative Commons Attribution-ShareAlike License.
  To view a copy of this license, visit \mbox{\url{http://creativecommons.org/licenses/by-sa/3.0/}}}

\newcommand{\email}[1]{\href{mailto:#1}{\nolinkurl{#1}}} % formatting emails
\newcommand{\pair}[2]{\langle#1,#2\rangle} % pairing function
\newcommand{\lb}{\left\{} % left curly brace for set notation
\newcommand{\rb}{\right\}} % right curly brace for set notation
\newcommand{\st}{\,\middle|\,} % ``such that'' pipe, for use in set definitions

\newenvironment{langdef}[1]{\begin{definition}{\lang{#1}}}{\end{definition}}
\newenvironment{instance}{\\Instance:}{}
\newenvironment{question}{\\Question:}{}

\newcommand{\pp}{PERM\mbox{-}PARSEABLE}
\newcommand{\pc}{PERM\mbox{-}CLOSED}
\newcommand{\pn}{PERM\mbox{-}NVQ}

\author{Jef{}frey~Finkelstein \and Andr\'as Kornai}
\title{Parsing first-order propositional logic}
\date{\today}

\begin{document}
\maketitle
\symbolfootnote{\makelicense}

In this work, we wish to determine the complexity of deciding whether a given multiset of symbols, chosen from some finite set of symbols, can be derived according to the rules of a given context-free grammar.
Providing an upper bound for this problem is of interest to computational linguistics, one goal of which is to classify the complexity of parsing and understanding natural language.

We define the context-free grammar of first-order propositional logic as follows.
\begin{definition}
  The language of first-order propositional logic consists of
  \begin{itemize}
  \item a set of variables $\{x_1, x_2, \ldots, x_n\}$,
  \item a set of constants $\{a_1, a_2, \ldots, a_c\}$,
  \item a set of functions $\{f^{m_1}_1, f^{m_2}_2, \ldots, f^{m_k}_k\}$, where each function $f_i$ has arity $m_i$,
  \item a set of relations (or ``propositions'') $\{R^{l_1}_1, R^{l_2}_2, \ldots, R^{l_d}_d\}$, where each relation $R_i$ has arity $l_i$, and
  \item a set of logical symbols $\{\land, \lor, \lnot, \exists, \forall, C\}$ (where $C$ represents a comma).
  \end{itemize}
  subject to the grammar described in \autoref{fig:grammar}.
  Without loss of generality, we will use Polish (prefix) notation for the grammar.
  \begin{figure}
    \caption{\label{fig:grammar}The context-free grammar specification in Backus--Naur form for first-order propositional logic (using Polish [prefix] notation).
    Here, $\lambda$ represents the empty string.}
  \begin{grammar}
    <term> := $x_i$, where $x_i$ is a variable
    \alt $a_i$, where $a_i$ is a term
    \alt $f^m_i(t_1, t_2, \ldots, t_m)$, where each $t_j$ is a <term>

    <formula> := $R^l_i(F_1, F_2, \ldots, F_l)$, where each $F_j$ is a <formula>
    \alt $\lor$ <formula> <formula>
    \alt $\land$ <formula> <formula>
    \alt $\lnot$ <formula>
    \alt $\exists x_i$ <formula>, where $x_i$ is a variable
    \alt $\forall x_i$ <formula>, where $x_i$ is a variable
  \end{grammar}
  \end{figure}
\end{definition}

\begin{technicality}\label{tch:encoding}
  In practice, decimal numbers may be encoded using binary strings.
  Additionally, symbols with indices or arities may not be treated atomically.
  However, we can encode, for example, a function $f_i^j$ (and similarly for a relation $R_i^j$) as the string $f0^i10^j$.
  More specifically, the application of the function $f_5^3$ to the inputs $x_1$, $x_2$, and $x_3$ can be encoded as $f000001000 x1 x10 x11$.
  This allows us to drop the commas as well, since the arity of the function is specified in the prefix.
\end{technicality}

\begin{technicality}\label{tch:boundedarity}
  We require that the arity of each function and relation is finite.
  With this restriction, we can describe first-order propositional logic with a context-free grammar.
  %% TODO cite Tarski and Givant 1987: A Formalization of Set Theory Without Variables. AMS, Providence RI
\end{technicality}

\begin{definition}
  Let $V$ be a set of variables, $A$ a set of constants, $F$ a set of functions (with their arities), $P$ a set of relations (with their arities), and $L$ the set of logical symbols.
  Let $w$ be a word over the alphabet $V\cup A\cup F\cup P\cup L$.
  Then $w$ is a \emph{well-formed formula} if there exists a parse-tree which generates $w$ according to the rules of the context-free grammar for first-order propositional logic given in the previous definition.

  A variable $x\in V$ is \emph{bound} if it is the descendant of a quantified formula in which that variable is quantified (either univerally as $\forall x$ or existentially as $\exists x$).
  A variable is \emph{free} if it is not bound.
  The \emph{scope} of a quantifier (with respect to its quantified variable) is the well-formed formula following it.
  A \emph{vacuous quantifier} is one whose quantified variable does not appear as a free variable in its scope (though the variable may appear as a bound variable).

  A \emph{closed formula} (or a \emph{sentence}) is a formula in which all variables appearing in the formula are bound.
\end{definition}

\begin{langdef}{PARSEABLE}
  \begin{instance}
    finite sets $V, A, F, P,$ and $L$ as described above, and $\phi$ a word over the alphabet $V\cup A\cup F\cup P\cup L$
  \end{instance}
  \begin{question}
    Is $\phi$ a well-formed formula?
  \end{question}
\end{langdef}

\begin{langdef}{CLOSED}
  \begin{instance}
    finite sets $V, A, F, P,$ and $L$ as described above, and $\phi$ a word over the alphabet $V\cup A\cup F\cup P\cup L$
  \end{instance}
  \begin{question}
    Is $\phi$ a closed well-formed formula?
  \end{question}
\end{langdef}

\begin{langdef}{NVQ}
  \begin{instance}
    finite sets $V, A, F, P,$ and $L$ as described above, and $\phi$ a word over the alphabet $V\cup A\cup F\cup P\cup L$
  \end{instance}
  \begin{question}
    Is $\phi$ a well-formed formula with no vacuous quantifiers?
  \end{question}
\end{langdef}

\lang{CLOSED} is sometimes called the ``no free variables'' problem, and \lang{NVQ} is sometimes called the ``no vacuous quantifiers'' problem.
Note that \lang{NVQ} does not require that the well-formed formula be closed, just that is has no vacuous quantifiers.

Let us define some complexity classes in order to help classify the complexity of these problems.
\begin{definition}\mbox{}
  \begin{itemize}
  \item $\CFL$ is the set of all context-free languages, or equivalently the set of all languages accepted by nondeterministic pushdown automata.
  \item $\DCFL$ is the set of all languages accepted by deterministic pushdown automata.
  \item $\CSL$ is the set of all context-sensitive languages, or equivalently the set of all languages accepted by linear-bounded automata.
  \item $\GCSL$ is the set of all context-sensitive languages in which the right side of each transformation in the context-sensitive grammar is either strictly longer than the left side or the left side is the start symbol.
  \item $\MCSL$ is the set of all mildly context-sensitive languages (for a precise definition, see \autoref{app:definitions}).
    % from Hopcroft Ullman
  \item $\INDEXED$ is the set of all indexed languages, or equivalently the set of all languages accepted by one-way nondeterministic nested stack automata.
  \item $\AC^1$ is the set of all languages accepted by non-uniform, polynomial size, $O(\lg(n))$, unbounded fan-in circuits with AND, OR, and NOT gates.
  \item $\NC^2$ is the set of all languages accepted by uniform, polynomial size, $O(\lg^2(n))$, fan-in 2 circuits with AND, OR, and NOT gates.
  \item $\P$ is the set of all languages accepted by a deterministic Turing machine running in polynomial time.
  \item $\NSPACE(n)$ is the set of all languages accepted by a nondeterministic Turing machine using at most $n$ space, where $n$ is the length of the input.
  \item $\NLINSPACE$ is the set of all languages accepted by a nondeterministic Turing machine using space at most linear in the length of the input.
  \item $\E$ is the set of all languages accepted by a deterministic Turing machine running in $2^{O(n)}$ time.
  \item $\NSA$ is the set of all languages accepted by one-way nondeterministic stack automata.
  \end{itemize}
\end{definition}
Indexed grammars were introduced by Aho in \cite{aho}.

The recognition problem (also known as the parsing problem) for a class of languages $\mathcal{C}$ is the problem of deciding membership in $\lb\pair{L}{w}\st w\in L \land L\in\mathcal{C} \rb$.
% source: Wikipedia article on CYK algorithm
The recognition problem for context-free languages is decidable in polynomial time (by, for example, the CYK algorithm).
The recognition problem for indexed languages is \EXP-complete \cite{tk86} (the cited article is not available, but I have ordered a copy of it from the library).

Just for context (pun intended), here's some inclusions among these complexity classes.
Some of these inclusions are strict.
\begin{theorem}\mbox{}
  \begin{enumerate}
    % source: complexity zoo
  \item $\CFL\subseteq\AC^1\subseteq\NC^2\subseteq\P$.
    % source: complexity zoo
  \item $\CFL\subseteq\GCSL\subseteq\CSL=\NSPACE(n)\subseteq\NLINSPACE\subseteq\E$.
  \item $\CFL\subseteq\NSA\subseteq\MCSL\subseteq\INDEXED\subseteq\CSL$ \cite{hu79}.
  \end{enumerate}
\end{theorem}

We know the following facts about the complexity of the three languages of interest.
\begin{itemize}
\item $\lang{PARSEABLE}\in\CFL$.
\item $\lang{CLOSED}\in\INDEXED\setminus\CFL$. \cite{mp84}
\item It is conjectured in \cite{mp84} that $\lang{NVQ}\notin\INDEXED$, though the complexity of this problem still seems to be unknown \cite{potts}.
\end{itemize}
\lang{CLOSED} may in fact be in a complexity class which is a subset of $\INDEXED$, like, for example, the class of mildly context-sensitive languages.
This seems to be an open problem.

In addition to the three problems defined above, we will consider three corresponding problems which are at least as difficult.
We wish to decide whether a given multiset of symbols has a permutation which is parseable, closed, or without vacuous quantifiers.
If $W$ is a multiset containing the symbols $a_1, a_2, \ldots, a_n$ (in some arbitrary order) and $\sigma\in S_n$ (that is, a permutation on $n$ elements), then we will denote by $\sigma(W)$ the sequence $(a_{\sigma(1)}, a_{\sigma(2)}, \ldots, a_{\sigma(n)})$.

\begin{langdef}{\pp}
  \begin{instance}
    finite sets $V, A, F, P,$ and $L$ as described above, and a multiset $\Phi$ with elements chosen from $V\cup A\cup F\cup P\cup L$
  \end{instance}
  \begin{question}
    Does there exist a permutation, $\sigma$, of the elements of $\Phi$ such that $\sigma(\Phi)\in\lang{PARSEABLE}$?
  \end{question}
\end{langdef}

\begin{langdef}{\pc}
  \begin{instance}
    finite sets $V, A, F, P,$ and $L$ as described above, and a multiset $\Phi$ with elements chosen from $V\cup A\cup F\cup P\cup L$
  \end{instance}
  \begin{question}
    Does there exist a permutation, $\sigma$, of the elements of $\Phi$ such that $\sigma(\Phi)\in\lang{CLOSED}$?
  \end{question}
\end{langdef}

\begin{langdef}{\pn}
  \begin{instance}
    finite sets $V, A, F, P,$ and $L$ as described above, and a multiset $\Phi$ with elements chosen from $V\cup A\cup F\cup P\cup L$
  \end{instance}
  \begin{question}
    Does there exist a permutation, $\sigma$, of the elements of $\Phi$ such that $\sigma(\Phi)\in\lang{NVQ}$?
  \end{question}
\end{langdef}

With these problems, we wish to capture the situation in which a human has a jumble of linguistic elements and is able to synthesize a natural language sentence.

\begin{conjecture}
  The recognition problem for the class of permuted indexed languages is \EXP-complete.
\end{conjecture}
\begin{rationale}
  Checking each permutation can be performed in exponential time, and the recognition problem for indexed languages reduces to it.
\end{rationale}

\section{About this work}

This work is licensed under the Creative Commons Attribution-ShareAlike License.
Visit \mbox{\url{https://creativecommons.org/licenses/by-sa/3.0/}} to view a copy of this license.

The \LaTeX{} markup which generated this document can be downloaded at \mbox{\url{https://github.com/jfinkels/parseable}}.
It is also licensed under the Creative Commons Attribution-ShareAlike License.

The author can be contacted via email at \email{jeffreyf@bu.edu}.

\bibliographystyle{plain}
\bibliography{bibliography}

\appendix
\section{Definition of ``mildly context-sensitive''}
\label{app:definitions}

The precise definition of the class of mildly context-sensitive languages comes from \cite{kallmeyer}.
It requires first this property of languages that states roughly that if one orders the strings in a language by increasing length, the difference between the lengths of two consecutive strings grows in a linear way.
\begin{definition}
  Let $\Sigma$ be an alphabet and $L\subseteq\Sigma^*$.
  $L$ has the \emph{constant growth property} if there is a constant $c_0>0$ and a finite set of positive constants $C\subseteq\mathbb{N}$ such that for all $w\in L$ with $|w|>c_0$, there exists a $w'\in L$ with $|w|=|w'|+c$ for some $c\in C$.
\end{definition}
\begin{definition}\mbox{}
  \begin{itemize}
  \item A language $L$ is \emph{mildly context-sensitive} if it is in $\P$ and has the constant-growth property.
  \item A class of languages $\mathcal{C}$ is \emph{mildly context-sensitive} if
    \begin{enumerate}
    \item All languages in $\mathcal{C}$ are mildly context-sensitive languages.
    \item $\CFL\subseteq\mathcal{C}$.
    \item $\mathcal{C}$ can describe \emph{cross-serial dependencies}, that is, there exists an $n\geq 2$ such that for all $k\leq n$, $\lb w^k \st w\in T^*\rb\in\mathcal{C}$.
    \end{enumerate}
  \item A formalism $\mathcal{F}$ (e.g. an abstract machine or a grammar) is \emph{mildly context-sensitive} if $\lb L \st \exists F\in\mathcal{F}\colon L = L(F)\rb$ is a mildly context-sensitive class of languages.
  \item Denote the largest mildly context-sensitive class of languages by $\MCSL$.
  \end{itemize}
\end{definition}

In \cite{kallmeyer}, Kallmeyer states, ``So far, it has not been possible to identify a grammar formalism that generates the largest possible mildly context-sensitive class of string languages.''
But she proposes a formalism which is more general than all known examples of mildly context-sensitive formalisms, yet still mildly context-sensitive itself.

\end{document}
