%%%%
%% parseable.tex
%%
%% Copyright 2012, 2014 Jeffrey Finkelstein.
%%
%% This work is licensed under the Creative Commons Attribution-ShareAlike 4.0
%% International License. To view a copy of this license, visit
%% http://creativecommons.org/licenses/by-sa/4.0/ or send a letter to Creative
%% Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041,
%% USA.
%%%%
\documentclass{article}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{complexity}
\usepackage[pdftitle={Parsing permutations of first-order propositional logic formulas}, pdfauthor={Jeffrey Finkelstein}]{hyperref}

\newtheorem{theorem}{Theorem}

\newtheorem{todo}{TODO}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{openproblem}{Open problem}

\newcommand{\email}[1]{\href{mailto:#1}{\nolinkurl{#1}}}
\newcommand{\lb}{\left\{} % left curly brace for set notation
\newcommand{\rb}{\right\}} % right curly brace for set notation
\newcommand{\st}{\,\middle|\,} % ``such that'' pipe, for use in set definitions
\newcommand{\yields}{\rightarrow}
\newcommand{\CLOSED}{\textsc{Closed}}
\newcommand{\PARSEABLE}{\textsc{Parseable}}
\newcommand{\NVQ}{\textsc{No Vacuous Quantifiers}}
\newcommand{\pp}{\textsc{Perm Parseable}}
\newcommand{\pc}{\textsc{Perm Closed}}
\newcommand{\pn}{\textsc{Perm NVQ}}

\newenvironment{langdef}[1]{\begin{definition}[#1]\mbox{}}{\end{definition}}
\newenvironment{instance}{\\Instance:}{}
\newenvironment{question}{\\Question:}{}

\author{Jeffrey~Finkelstein \and Andr\'as~Kornai}
\title{Parsing permutations of first-order propositional logic formulas}
\date{\today}

\begin{document}
\maketitle

In this work, we wish to determine the complexity of deciding whether a given multiset of symbols, chosen from some finite set of symbols, can be derived according to the rules of a given context-free grammar.
Providing an upper bound for this problem is of interest to computational linguistics, one goal of which is to classify the complexity of parsing and understanding natural language.

We consider a simplified subset of fist-order propositional logic consisting of only those formulas containing universal quantification, conjunction operations, and equality relations.
Variables $x_i$ will be represented as $i$ repetitions of the symbol $x$ (for example, $x_3$ becomes $xxx$).
\begin{definition}[\cite{mp84}]
  The context-free language $L$ of \emph{restricted first-order propositional logic} is defined by the following context-free grammar.
  The set of terminals is $\left\{\land, =, \forall, x, (, ) \right\}$, the set of nonterminals is $\{S, V\}$, and the grammar is as follows.
  \begin{align*}
    S &\yields (S \land S) \\
    S &\yields (V = V) \\
    S &\yields \forall \, V S \\
    V &\yields Vx \\
    V &\yields x
  \end{align*}
  A string generated by this grammar is called a \emph{well-formed formula}.
\end{definition}

%% \begin{remark}\label{tch:encoding}
%%   In practice, decimal numbers may be encoded using binary strings.
%%   Additionally, symbols with indices or arities may not be treated atomically.
%%   However, we can encode, for example, a function $f_i^j$ (and similarly for a relation $R_i^j$) as the string $f0^i10^j$.
%%   More specifically, the application of the function $f_5^3$ to the inputs $x_1$, $x_2$, and $x_3$ can be encoded as $f000001000 x1 x10 x11$.
%%   This allows us to drop the commas as well, since the arity of the function is specified in the prefix.
%% \end{remark}

%% \begin{remark}\label{tch:boundedarity}
%%   We require that the arity of each function and relation is finite.
%%   With this restriction, we can describe first-order propositional logic with a context-free grammar.
%%   %% TODO cite Tarski and Givant 1987: A Formalization of Set Theory Without Variables. AMS, Providence RI
%% \end{remark}

\begin{definition}
  Consider a string in the language $L$ and its associated parse-tree.
  A variable $x_i$ is \emph{bound} if it is the descendant of a quantified formula in which that variable is quantified; a variable is \emph{free} if it is not bound.
  The \emph{scope} of a quantifier (with respect to its quantified variable) is the well-formed formula following it (that is, the formula $S$ in the production $S \yields \forall \, V S$).

  A \emph{vacuous quantifier} is one whose quantified variable does not appear as a free variable in its scope (though the variable may appear as a bound variable).
  A \emph{closed formula} (or a \emph{sentence}) is a formula in which all variables appearing in the formula are bound.
\end{definition}

In each of the problems defined below, the alphabet $T$ is the set of terminals in the grammar of $L$.
\begin{langdef}{\PARSEABLE}
  \begin{instance}
    a word $\phi$ over the alphabet $T$
  \end{instance}
  \begin{question}
    Is $\phi$ a well-formed formula?
    (In other words, is $\phi$ in $L$?)
  \end{question}
\end{langdef}

\begin{langdef}{\CLOSED}
  \begin{instance}
    a word $\phi$ over the alphabet $T$
  \end{instance}
  \begin{question}
    Is $\phi$ a closed well-formed formula?
  \end{question}
\end{langdef}

\begin{langdef}{\NVQ}
  \begin{instance}
    a word $\phi$ over the alphabet $T$
  \end{instance}
  \begin{question}
    Is $\phi$ a well-formed formula with no vacuous quantifiers?
  \end{question}
\end{langdef}

\CLOSED{} is sometimes called the ``no free variables'' problem, and \NVQ{} is sometimes called the ``no vacuous quantifiers'' problem.
\CLOSED{} does not require that the formula has no vacuous quantifiers and \NVQ{} does not require that the formula be closed.

Let us define some complexity classes in order to help classify the complexity of these problems.
\begin{definition}\mbox{}
  \begin{itemize}
  \item $\CFL$ is the set of all context-free languages, or equivalently the set of all languages accepted by nondeterministic pushdown automata.
  \item $\DCFL$ is the set of all languages accepted by deterministic pushdown automata.
  \item $\CSL$ is the set of all context-sensitive languages, or equivalently the set of all languages accepted by linear-bounded automata.
  \item $\GCSL$ is the set of all context-sensitive languages in which the right side of each transformation in the context-sensitive grammar is either strictly longer than the left side or the left side is the start symbol.
  \item $\MCSL$ is the set of all mildly context-sensitive languages (for a precise definition, see \autoref{app:definitions}).
    % from Hopcroft Ullman
  \item $\INDEXED$ is the set of all indexed languages, or equivalently the set of all languages accepted by one-way nondeterministic nested stack automata \cite{aho}.
  \item $\AC^1$ is the set of all languages accepted by non-uniform, polynomial size, $O(\log n)$, unbounded fan-in circuits with AND, OR, and NOT gates.
  \item $\NC^2$ is the set of all languages accepted by uniform, polynomial size, $O(\log^2 n)$, fan-in 2 circuits with AND, OR, and NOT gates.
  \item $\P$ is the set of all languages accepted by a deterministic Turing machine running in polynomial time.
  \item $\NSPACE(n)$ is the set of all languages accepted by a nondeterministic Turing machine using at most $n$ space, where $n$ is the length of the input.
  \item $\NLINSPACE$ is the set of all languages accepted by a nondeterministic Turing machine using space at most linear in the length of the input.
  \item $\E$ is the set of all languages accepted by a deterministic Turing machine running in $2^{O(n)}$ time.
  \item $\NSA$ is the set of all languages accepted by one-way nondeterministic stack automata.
  \end{itemize}
\end{definition}

Here are some inclusions among these complexity classes.
Some of these inclusions are strict.
\begin{theorem}\mbox{}
  \begin{enumerate}
    % source: complexity zoo
  \item $\CFL\subseteq\AC^1\subseteq\NC^2\subseteq\P$.
    % source: complexity zoo
  \item $\CFL\subseteq\GCSL\subseteq\CSL=\NSPACE(n)\subseteq\NLINSPACE\subseteq\E$.
  \item $\CFL\subseteq\NSA\subseteq\MCSL\subseteq\INDEXED\subseteq\CSL$ \cite{hu79}.
  \end{enumerate}
\end{theorem}

We know the following facts about the complexity of the three languages of interest.
\begin{itemize}
\item $\PARSEABLE \in \CFL$.
\item $\CLOSED \in \INDEXED \setminus \CFL$. \cite{mp84}
\item It is conjectured in \cite{mp84} that $\NVQ \notin \INDEXED$, though the complexity of this problem still seems to be unknown \cite{potts}.
\end{itemize}

%% The general \emph{recognition problem} (also known as the \emph{parsing problem} or \emph{membership problem}) for a class of languages $\mathcal{C}$ is the problem of deciding membership in $\lb\pair{A}{w} \st A \in \mathcal{C} \text{ and } w \in A \rb$.
%% The recognition problem for indexed languages is \EXP-complete \cite{tk86}.
%% %% I have a print copy of the cited article somewhere.
%% (Compare with the recognition problem for context-free languages, which is decidable in polynomial time by, for example, the CYK algorithm.)
%% % source: Wikipedia article on CYK algorithm

\begin{openproblem}
  Is \CLOSED{} a mildly context-sensitive language (more formally, is $\CLOSED \in \MCSL \setminus \CFL$)? Could it be decided by, for example, an instance of the formalism described in \cite{kallmeyer}?
\end{openproblem}

\begin{openproblem}
  Is $\NVQ \notin \INDEXED$?
\end{openproblem}

We will consider also permutation problems corresponding to \PARSEABLE, \CLOSED, and \NVQ.
In the definitions below, if $w$ is a word composed of symbols $w_1 \dotsb w_n$ and $\sigma$ is a permutation on $n$ elements then we define $\sigma(w) = w_{\sigma(1)} \dotsb w_{\sigma(n)}$.

\begin{langdef}{\pp}
  \begin{instance}
    a word $\phi$ of length $n$ over the alphabet $T$
  \end{instance}
  \begin{question}
    Is there a permutation $\sigma$ on $n$ elements such that $\sigma(\phi)$ is a well-formed formula?
    (In other words, is $\sigma(\phi)$ in \PARSEABLE?)
  \end{question}
\end{langdef}

\begin{langdef}{\pc}
  \begin{instance}
    a word $\phi$ of length $n$ over the alphabet $T$
  \end{instance}
  \begin{question}
    Is there a permutation $\sigma$ on $n$ elements such that $\sigma(\phi)$ is a closed well-formed formula?
    (In other words, is $\sigma(\phi)$ in \CLOSED?)
  \end{question}
\end{langdef}

\begin{langdef}{\pn}
  \begin{instance}
    a word $\phi$ of length $n$ over the alphabet $T$
  \end{instance}
  \begin{question}
    Is there a permutation $\sigma$ on $n$ elements such that $\sigma(\phi)$ is a well-formed formula with no vacuous quantifiers?
    (In other words, is $\sigma(\phi)$ in \NVQ?)
  \end{question}
\end{langdef}

With these problems, we wish to capture the situation in which a human has a jumble of linguistic elements and is able to synthesize a natural language sentence (preferably one which is semantically valid, but we will just consider syntax for now).

\begin{todo}
  Explain the significance of the \pp, \pc, and \pn{} problems with respect to natural language parsing and computational linguistics.
\end{todo}

\begin{openproblem}
  Is either of \pc{} or \pn{} in \INDEXED?
  Is either in \MCSL?
  Generally, permutations of parseable languages are easier than the originals (if the number of terminal symbols meets some requirement, then we can rearrange them to choose any appropriate parse-tree), so it should be possible to put $\pc \in \INDEXED$.
  To show this, one might start by showing that a one-way nondeterministic nested stack automaton accepts $\pc$.
  Or that a linear indexed grammar generates all words $\phi$ which have some permutation which is a closed well-formed formula.
\end{openproblem}

\autoref{fig:closedlmg} is a fragment of a combinatorial, linear, non-erasing literal movement grammar for \pc.
\autoref{fig:nvqlmg} is a fragment of a combinatorial, linear, non-erasing literal movement grammar for \pn.

\begin{figure}
  \caption{
    \label{fig:closedlmg}
    Literal movement grammar for \pc.
    $Q_i$ represents a quantification of variable $x_i$.
    After quantification, this grammar allows any number of instances of the variable $x_i$ to occur in rule $V_i$.
    The rules for producing the other symbols of first-order propositional logic have been omitted, as represented by the vertical ellipsis.
    Note: this grammar can derive strings with vacuous quantifiers.
  }
  \begin{align*}
    & S(\epsilon) \rightarrow \epsilon \\
    & S(X) \rightarrow Q_i(X) \\
    & Q_i(X \, \forall \, Y \, x_i \, Z) \rightarrow V_i(X \, Y \, Z) \\
    & Q_i(X \, x_i \, Y \, \forall \, Z) \rightarrow V_i(X\, Y \, Z) \\
    & V_i(X \, x_i \, Y) \rightarrow V_i(X \, Y) \\
    & V_i(X) \rightarrow S(X) \\
    & \vdots
  \end{align*}
\end{figure}

\begin{figure}
  \caption{
    \label{fig:nvqlmg}
    Literal movement grammar for \pn.
    $V_i$ represents an instance of variable $x_i$.
    After generating any number of instances of variable $x_i$, it is quantified by the rule $Q_i$.
    After that, production of instances of variable $x_{i+1}$ is allowed.
    Shortcuts are provided for skipping any unused variables to avoid vacuous quantification.
    The rules for producing the other symbols of first-order propositional logic follow from rule $R$ and are omitted here, as represented by the second vertical ellipsis.
    Note: this grammar can derive strings with free variables.
  }
  \begin{align*}
    & S(\epsilon) \rightarrow \epsilon \\
    & S(X) \rightarrow Q_i(X) \\
    & V_1(X \, x_i \, Y) \rightarrow V_1(X \, Y) \\
    & V_1(X) \rightarrow Q_1(X) \\
    & V_1(X) \rightarrow V_2(X) \\
    & Q_1(X \, \forall \, Y \, x_1 \, Z) \rightarrow V_2(X \, Y \, Z) \\
    & Q_1(X \, x_1 \, Y \, \forall \, Z) \rightarrow V_2(X \, Y \, Z) \\
    & \vdots \\
    & Q_n(X \, x_n \, Y \, \forall \, Z) \rightarrow R(X \, Y \, Z) \\
    & Q_n(X \, \forall \,  Y \, x_n \, Z) \rightarrow R(X \, Y \, Z) \\
    & \vdots
  \end{align*}
\end{figure}

\begin{todo}
  Definition of combinatorial, linear, non-erasing literal movement grammars.
\end{todo}
\begin{todo}
  Determine the complexity of the literal movement grammar in \autoref{fig:closedlmg} and \autoref{fig:nvqlmg}.
\end{todo}

\section{About this work}

Copyright 2012, 2013, 2014 Jeffrey~Finkelstein.

This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.
To view a copy of this license, visit the website \mbox{\url{https://creativecommons.org/licenses/by-sa/4.0/}}.

The \LaTeX{} markup that generated this document is available on its website \mbox{\url{https://github.com/jfinkels/parseable}}.
The markup is distributed under the same license.

The author can be contacted via email at \email{jeffreyf@bu.edu}.

\bibliographystyle{plain}
\bibliography{bibliography}

\appendix
\section{Definition of ``mildly context-sensitive''}
\label{app:definitions}

The precise definition of the class of mildly context-sensitive languages comes from \cite[Definition~1]{kallmeyer}.
We refer you to that work for the precise definition of the ``constant growth property'' that states roughly that if one orders the strings in a language by increasing length, the difference between the lengths of two consecutive strings grows in a linear way.
\begin{definition}\mbox{}
  \begin{itemize}
  \item A language $L$ is \emph{mildly context-sensitive} if it is in $\P$ and has the constant-growth property.
  \item A class of languages $\mathcal{C}$ is \emph{mildly context-sensitive} if
    \begin{enumerate}
    \item All languages in $\mathcal{C}$ are mildly context-sensitive languages.
    \item $\CFL\subseteq\mathcal{C}$.
    \item $\mathcal{C}$ can describe \emph{cross-serial dependencies}, that is, there exists an $n\geq 2$ such that for all $k\leq n$, $\lb w^k \st w\in T^*\rb\in\mathcal{C}$.
    \end{enumerate}
  \item A formalism $\mathcal{F}$ (e.g. an abstract machine or a grammar) is \emph{mildly context-sensitive} if $\lb L \st \exists F\in\mathcal{F}\colon L = L(F)\rb$ is a mildly context-sensitive class of languages.
  \item Denote the largest mildly context-sensitive class of languages by $\MCSL$.
  \end{itemize}
\end{definition}

In \cite{kallmeyer}, Kallmeyer states, ``So far, it has not been possible to identify a grammar formalism that generates the largest possible mildly context-sensitive class of string languages.''
But she proposes a formalism which is more general than all known examples of mildly context-sensitive formalisms, yet still mildly context-sensitive itself.

\end{document}
